name: Bootstrap a new account in access-control repo
description: "Sets up a new AWS account and basic roles inside the access control repo"
inputs:
  gruntwork_code_access_token:
    description: "The GRUNTWORK_CODE_ACCESS_TOKEN Secret"
    required: true
  gruntwork_context:
    description: "Gruntwork Context From the Gruntwork Bootstrap step"
    required: true

runs:
  using: composite
  steps:
    - name: "[Baseline]: Read account request"
      id: gruntwork_context
      uses: gruntwork-io-team/pipelines-bootstrap@main
      with:
        cache: ${{ inputs.gruntwork_context }}

    - name: "[Baseline]: Run terragrunt ${{ steps.gruntwork_context.outputs.terragrunt_command }} in security account"
      id: terragrunt-apply-security
      uses: gruntwork-io-team/pipelines-aws-execute@main
      with:
        aws_region: ${{ steps.gruntwork_context.outputs.default_aws_region }}
        gruntwork_code_access_token: ${{ inputs.gruntwork_code_access_token }}
        terragrunt_command: ${{ steps.gruntwork_context.outputs.terragrunt_command }}
        account_id: ${{ steps.gruntwork_context.outputs.security_account_id }}
        account_role_name: ${{ steps.gruntwork_context.outputs.role_name }}
        role_session_name: ${{ steps.gruntwork_context.outputs.role_session_name }}
        working_directory: security/_global/account-baseline
        terraform_version: ${{ steps.gruntwork_context.outputs.terraform_version }}
        terragrunt_version: ${{ steps.gruntwork_context.outputs.terragrunt_version }}
        gruntwork_config_file: ${{ steps.gruntwork_context.outputs.gruntwork_config_file }}
        pipelines_cli_version: ${{ steps.gruntwork_context.outputs.pipelines_cli_version }}


    - name: "[Baseline]: Run terragrunt ${{ steps.gruntwork_context.outputs.terragrunt_command }} in logs account"
      id: terragrunt-apply-logs
      uses: gruntwork-io-team/pipelines-aws-execute@main
      with:
        aws_region: ${{ steps.gruntwork_context.outputs.default_aws_region }}
        gruntwork_code_access_token: ${{ inputs.gruntwork_code_access_token }}
        terragrunt_command: ${{ steps.gruntwork_context.outputs.terragrunt_command }}
        account_id: ${{ steps.gruntwork_context.outputs.logs_account_id }}
        account_role_name: ${{ steps.gruntwork_context.outputs.role_name }}
        role_session_name: ${{ steps.gruntwork_context.outputs.role_session_name }}
        working_directory: logs/_global/account-baseline
        terraform_version: ${{ steps.gruntwork_context.outputs.terraform_version }}
        terragrunt_version: ${{ steps.gruntwork_context.outputs.terragrunt_version }}
        gruntwork_config_file: ${{ steps.gruntwork_context.outputs.gruntwork_config_file }}
        pipelines_cli_version: ${{ steps.gruntwork_context.outputs.pipelines_cli_version }}



    - name: "[Baseline]: Run terragrunt ${{ steps.gruntwork_context.outputs.terragrunt_command }} in shared account"
      id: terragrunt-apply-shared
      uses: gruntwork-io-team/pipelines-aws-execute@main
      with:
        aws_region: ${{ steps.gruntwork_context.outputs.default_aws_region }}
        gruntwork_code_access_token: ${{ inputs.gruntwork_code_access_token }}
        terragrunt_command: ${{ steps.gruntwork_context.outputs.terragrunt_command }}
        account_id: ${{ steps.gruntwork_context.outputs.shared_account_id }}
        account_role_name: ${{ steps.gruntwork_context.outputs.role_name }}
        role_session_name: ${{ steps.gruntwork_context.outputs.role_session_name }}
        working_directory: shared/_global/account-baseline
        terraform_version: ${{ steps.gruntwork_context.outputs.terraform_version }}
        terragrunt_version: ${{ steps.gruntwork_context.outputs.terragrunt_version }}
        gruntwork_config_file: ${{ steps.gruntwork_context.outputs.gruntwork_config_file }}
        pipelines_cli_version: ${{ steps.gruntwork_context.outputs.pipelines_cli_version }}



    # Finally, auth to the mgmt account so we can assume a role in the child account
    - name: "[Baseline]: Authenticate to AWS"
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region:  ${{ steps.gruntwork_context.outputs.default_aws_region }}
        role-to-assume: "arn:aws:iam::${{ steps.gruntwork_context.outputs.account_id }}:role/${{ steps.gruntwork_context.outputs.role_name }}"
        role-duration-seconds: 3600
        role-session-name: ${{ steps.gruntwork_context.outputs.role_session_name }}

    # Auth to child account
    # THIS RETRIEVES PERMISSIONS TO BE ABLE TO RUN A PLAN/APPLY IN THE NEWLY CREATED CHILD ACCOUNT
    # The "AWSControlTowerExecution" role being assumed here is created by Control Tower in each account it provisions
    # and it can be assumed by a role in the management account.
    - name: "[Baseline]: Assume role new child account"
      shell: bash
      env:
        SESSION_NAME: ${{ steps.gruntwork_context.outputs.role_session_name }}
        CHILD_ACCOUNT: ${{ steps.gruntwork_context.outputs.child_account_id }}
      run: |
        RESPONSE="$(aws sts assume-role --role-arn "arn:aws:iam::$CHILD_ACCOUNT:role/AWSControlTowerExecution" --role-session-name "$SESSION_NAME")"
        ASSUMED_ROLE_CREDS="$(echo "$RESPONSE" | jq -r '.Credentials')"
        AWS_ACCESS_KEY_ID="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.AccessKeyId')"
        echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> "$GITHUB_ENV"
        echo "::add-mask::$AWS_ACCESS_KEY_ID"
        AWS_SECRET_ACCESS_KEY="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.SecretAccessKey')"
        echo AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" >> "$GITHUB_ENV"
        echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
        AWS_SESSION_TOKEN="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.SessionToken')"
        echo AWS_SESSION_TOKEN="$AWS_SESSION_TOKEN" >> "$GITHUB_ENV"
        echo "::add-mask::$AWS_SESSION_TOKEN"

    - name: "[Baseline]: Confirm Account Access"
      shell: bash
      env:
        CHILD_ACCOUNT: ${{ steps.gruntwork_context.outputs.child_account_id }}
        WORKING_DIRECTORY: ${{ steps.gruntwork_context.outputs.working_directory }}
      run: echo "::notice ::Running in account $CHILD_ACCOUNT and planning in $WORKING_DIRECTORY"

    # This Bootstrap step is a workaround for the error that happens when running plan-all for the first time in a
    # new account with multiple modules. The error is:
    #
    #    OperationAborted: A conflicting conditional operation is currently in progress against this resource. Please try again.
    #    BucketAlreadyOwnedByYou: Your previous request to create the named bucket succeeded and you already own it.
    #
    # This happens because each module is trying to create buckets for state and logs when they do not exist.
    # Setting Terragrunt Parallelism to 1 does NOT prevent this error from happening. So we'll instead run an init in
    # a single module first to create the buckets so that subsequent run-all commands do not fail.
    - name: "[Baseline]: Bootstrap child account with state & logs S3 buckets"
      if: ${{ contains(steps.gruntwork_context.outputs.terragrunt_command, 'plan') }}
      uses: gruntwork-io/pipelines-execute@v3.0.0
      with:
        token: ${{ inputs.gruntwork_code_access_token }}
        tf_version: ${{ steps.gruntwork_context.outputs.terraform_version }}
        tg_version: ${{ steps.gruntwork_context.outputs.terragrunt_version }}
        pipelines_cli_version: ${{ steps.gruntwork_context.outputs.pipelines_cli_version }}
        working_directory: "${{ steps.gruntwork_context.outputs.working_directory }}/_global/account-baseline"
        terragrunt_command: "init"
        infra_live_repo: '.'
        infra_live_directory: '.'
        infra_live_repo_branch: ${{ steps.gruntwork_context.outputs.branch }}
        gruntwork_config: "${{ steps.gruntwork_context.outputs.gruntwork_config }}"

    # Apply Access Control Roles and Baseline in Delegated Account
    - name: "[Baseline]: Bootstrap child account with access control roles, state & logs S3 buckets"
      uses: gruntwork-io/pipelines-execute@v3.0.0
      with:
        token: ${{ inputs.gruntwork_code_access_token }}
        tf_version: ${{ steps.gruntwork_context.outputs.terraform_version }}
        tg_version: ${{ steps.gruntwork_context.outputs.terragrunt_version }}
        pipelines_cli_version: ${{ steps.gruntwork_context.outputs.pipelines_cli_version }}
        working_directory: "${{ steps.gruntwork_context.outputs.working_directory }}/_global/account-baseline"
        terragrunt_command: ${{ steps.gruntwork_context.outputs.terragrunt_command }}
        infra_live_repo: '.'
        infra_live_directory: '.'
        infra_live_repo_branch: ${{ steps.gruntwork_context.outputs.branch }}
        gruntwork_config: "${{ steps.gruntwork_context.outputs.gruntwork_config }}"

    # Create Access Control PR
    # Merge Access Control PR
    - name: "[ProvisionAccount]: Setup Access Control Repo PR"
      id: create_roles_for_access_control
      if: ${{ steps.bootstrap.outputs.action == '' }}
      uses: gruntwork-io-team/pipelines-provision-access-control@main
      with:
        gruntwork_context: ${{ toJson(steps.bootstrap.outputs) }}
        gruntwork_code_access_token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
        # TODO - this needs to be a different token that has enhanced scopes for creating repos
        manage_repo_token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}

    # Create Delegated Repo
    # Create PR in Delegated Repo
    - name: "[ProvisionDelegatedRepo]: Setup delegated Repo"
      id: provision_delegated_repo
      if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' }}
      uses: gruntwork-io-team/pipelines-provision-repo-action@main
      with:
        gruntwork_context: ${{ toJson(steps.bootstrap.outputs) }}
        gruntwork_code_access_token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
        # TODO - this needs to be a different token that has enhanced scopes for creating repos
        manage_repo_token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
